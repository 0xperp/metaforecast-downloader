<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Chart example</title>
    <style>
     body, html, main {
       margin: 0;
       padding: 0;
       height: 100%;
       box-sizing: border-box;
     }
     main {
       padding: 1em 0;
       display: flex;
       justify-content: center;
       align-items: center;
     }
     main>section {
       flex: 0 0 700px;
       height: 100%;
       width: 700px;
     }
     .question {
       display: flex;
       flex-direction: row;
       gap: 1em;
     }
     .chart-container {
       height: 400px;
       width: 500px;
       flex: 0 0 500px;
     }
     .chart {
       display: none;
       height: 100%;
     }
     .legend {
       flex: 0 0 100px;
       list-style: none;
       margin: 0;
       padding: 0;
     }
     .legend>li {
       display: flex;
       gap: 0.25em;
       font-family: sans-serif;
       font-size: 0.75em;
     }
     .color-box {
       border: 1px solid #aaa;
       flex: 0 0 1em;
       height: 1em;
       align-self: center;
     }
    </style>
  </head>
  <body>
    <main class="columns">
      <section>
        <article data-file="Crimea.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
        <article data-file="Escalation.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
        <article data-file="Nuclear.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
      </section>
      <section>
        <article data-file="Peace.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
        <article data-file="Putin.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
        <article data-file="Territory.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
      </section>
      <section>
        <article data-file="Threads.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
        <article data-file="Threads2.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
        <article data-file="Wagner.json" class="question">
          <div class="chart-container">
            <canvas class="chart"></canvas>
          </div>
          <ul class="legend"></ul>
        </article>
      </section>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.3"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.3.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1"></script>
    <script>
     function formatPct(p) {
       return Intl.NumberFormat("en-US", { style: "percent"}).format(p)
     }

     const colors = ['#1d6996','#edad08','#73af48','#94346e','#38a6a5','#e17c05'];
     const containers = document.querySelectorAll('article');

     // interaction mode to get the most recent point to the left of the hover;
     // see https://www.chartjs.org/docs/latest/configuration/interactions.html
     Chart.Interaction.modes.priorX = function(chart, e) {
       const items = [];
       const metasets = chart.getSortedVisibleDatasetMetas();
       const position = Chart.helpers.getRelativePosition(e, chart);
       const value = position.x;
       for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
         const { index, data } = metasets[i];
         // binary search the location of the hovered x value in the dataset
         const { lo, hi } = Chart.helpers._lookupByKey(data, 'x', value)
         const prev = lo - 1;
         if (prev >= 0) {
           items.push({ datasetIndex: i, index: prev, element: data[prev] })
         }
       }
       return items;
     };

     for (const container of containers) {
       const canvas = container.querySelector(".chart");
       const legend = container.querySelector(".legend");

       fetch(container.dataset.file).then(async (res) => {
         const markets = await res.json();
         const datasets = markets.map((mkt, i) => ({
           label: mkt.name,
           q: mkt.q,
           data: mkt.points,
           borderWidth: 2,
           borderColor: colors[i],
           backgroundColor: colors[i]
         }))
         let hoverState = undefined;
         new Chart(canvas, {
           type: 'line',
           data: { datasets },
           plugins: [{
             // tracks the hover state for the tooltip and vertical cursor
             beforeEvent: (chart, args) => {
               const event = args.event;
               if (event.type === 'mousemove') {
                 const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                 const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                 const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);
                 hoverState = { canvasPosition, data: { x: dataX, y: dataY } };
               }
             },
             // draws the vertical cursor on hover, via https://stackoverflow.com/a/68140000
             afterDraw: (chart) => {
               if (chart.tooltip?._active?.length && hoverState) {
                 const x = hoverState.canvasPosition.x;
                 const yAxis = chart.scales.y;
                 const ctx = chart.ctx;
                 ctx.save();
                 ctx.beginPath();
                 ctx.moveTo(x, yAxis.top);
                 ctx.lineTo(x, yAxis.bottom);
                 ctx.lineWidth = 1;
                 ctx.strokeStyle = 'rgba(0, 0, 255, 0.4)';
                 ctx.stroke();
                 ctx.restore();
               }
             },
             // draws the legend, see https://www.chartjs.org/docs/latest/samples/legend/html.html
             afterUpdate: (chart, args, options) => {
               const entries = chart.options.plugins.legend.labels.generateLabels(chart);
               const listItems = entries.map(entry => {
                 const li = document.createElement('li');
                 const box = document.createElement('span');
                 box.className = "color-box";
                 box.style.background = entry.fillStyle;
                 box.style.borderColor = entry.strokeStyle;
                 box.style.borderWidth = '1px';
                 const link = document.createElement('a');
                 link.href = markets[entry.datasetIndex].url;
                 link.append(entry.text);
                 li.append(box, link);
                 return li
               });
               legend.replaceChildren(...listItems)
             }
           }],
           options: {
             maintainAspectRatio: false,
             interaction: { mode: 'priorX', intersect: false },
             plugins: {
               legend: { display: false }, // our custom legend plugin drawing will do it
               tooltip: {
                 itemSort: (a, b) => b.parsed.y - a.parsed.y,
                 callbacks: {
                   title: (items) => new Date(hoverState.data.x).toDateString(),
                   label: (item) => {
                     const { dataset } = item;
                     if (dataset.q) {
                       return `${dataset.q} (${dataset.label}): ${formatPct(item.parsed.y)}`
                     } else {
                       return `${dataset.label}: ${formatPct(item.parsed.y)}`
                     }
                   }
                 }
               }
             },
             elements: { point: { radius: 0 } },
             scales: {
               x: { type: 'time', grid: { drawOnChartArea: false } },
               y: { ticks: { callback: formatPct } }
             }
           }
         });
       })
     }
    </script>
  </body>
</html>
